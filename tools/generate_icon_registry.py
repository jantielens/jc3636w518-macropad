#!/usr/bin/env python3
"""Generate a tiny icon registry for compiled LVGL mono (mask) icon assets.

This scans generated icon asset headers for declarations like:
  extern const lv_img_dsc_t ic_volume_up;

Then emits:
  - src/app/icon_registry.h
  - src/app/icon_registry.cpp

so firmware can resolve a compiled icon_id (e.g. "volume_up") to the compiled
symbol (&ic_volume_up).

Note: full-color icons are supported via FFat-installed blobs (icon_store), not
via compiled assets.

Usage:
  python3 tools/generate_icon_registry.py \
    --mono-h src/app/icon_assets_mono.h \
    --out-h  src/app/icon_registry.h \
    --out-cpp src/app/icon_registry.cpp

Notes:
- This keeps the runtime lookup explicit and static (no dynamic symbol resolution).
- The registry is only compiled when HAS_DISPLAY && HAS_ICONS.
"""

from __future__ import annotations

import argparse
import os
import re
import sys
from dataclasses import dataclass
from typing import List


_DECL_RE = re.compile(r"^\s*extern\s+const\s+lv_img_dsc_t\s+(?P<sym>[A-Za-z_][A-Za-z0-9_]*)\s*;\s*$")


@dataclass(frozen=True)
class IconSym:
    icon_id: str
    symbol: str


def _read_symbols(path: str, expected_prefix: str) -> List[IconSym]:
    if not path or not os.path.exists(path):
        return []

    out: List[IconSym] = []
    with open(path, "r", encoding="utf-8") as f:
        for line in f:
            m = _DECL_RE.match(line)
            if not m:
                continue
            sym = m.group("sym")
            if not sym.startswith(expected_prefix):
                continue
            icon_id = sym[len(expected_prefix) :]
            out.append(IconSym(icon_id=icon_id, symbol=sym))

    # Deterministic order
    out.sort(key=lambda s: s.icon_id)
    return out


def _write_header(out_h: str) -> None:
    guard = "ICON_REGISTRY_H"
    with open(out_h, "w", encoding="utf-8") as f:
        f.write("/*\n")
        f.write(" * Auto-generated icon registry\n")
        f.write(" * Generated by tools/generate_icon_registry.py\n")
        f.write(" * DO NOT EDIT MANUALLY\n")
        f.write(" */\n\n")
        f.write(f"#ifndef {guard}\n")
        f.write(f"#define {guard}\n\n")
        f.write('#include "board_config.h"\n\n')
        f.write("#if HAS_DISPLAY && HAS_ICONS\n")
        f.write("#include <stddef.h>\n")
        f.write("#include <lvgl.h>\n\n")
        f.write("#ifdef __cplusplus\n")
        f.write("extern \"C\" {\n")
        f.write("#endif\n\n")
        f.write("enum class IconKind : uint8_t {\n")
        f.write("  Mask = 0,\n")
        f.write("  Color = 1,\n")
        f.write("};\n\n")
        f.write("struct IconRef {\n")
        f.write("  const lv_img_dsc_t* dsc;\n")
        f.write("  IconKind kind;\n")
        f.write("};\n\n")
        f.write("// Returns true if icon_id maps to a compiled icon.\n")
        f.write("bool icon_registry_lookup(const char* icon_id, IconRef* out);\n\n")

        f.write("// Returns the number of compiled icons.\n")
        f.write("size_t icon_registry_count();\n")
        f.write("\n")
        f.write("// Returns the icon_id for the given index, or nullptr if out of range.\n")
        f.write("const char* icon_registry_id_at(size_t index);\n")
        f.write("\n")
        f.write("// Returns the IconKind for the given index (Mask by default if out of range).\n")
        f.write("IconKind icon_registry_kind_at(size_t index);\n\n")
        f.write("#ifdef __cplusplus\n")
        f.write("}\n")
        f.write("#endif\n\n")
        f.write("#endif // HAS_DISPLAY && HAS_ICONS\n\n")
        f.write(f"#endif // {guard}\n")


def _write_cpp(out_cpp: str, out_h_basename: str, mono: List[IconSym]) -> None:
    with open(out_cpp, "w", encoding="utf-8") as f:
        f.write("/*\n")
        f.write(" * Auto-generated icon registry\n")
        f.write(" * Generated by tools/generate_icon_registry.py\n")
        f.write(" * DO NOT EDIT MANUALLY\n")
        f.write(" */\n\n")
        f.write(f'#include "{out_h_basename}"\n')
        f.write("\n#if HAS_DISPLAY && HAS_ICONS\n\n")
        f.write("#include <string.h>\n\n")
        f.write("// Include generated icon declarations\n")
        f.write('#include "icon_assets_mono.h"\n\n')

        f.write("struct IconEntry {\n")
        f.write("  const char* id;\n")
        f.write("  const lv_img_dsc_t* dsc;\n")
        f.write("  IconKind kind;\n")
        f.write("};\n\n")

        f.write("static const IconEntry kIcons[] = {\n")
        for s in mono:
            f.write(f'  {{"{s.icon_id}", &{s.symbol}, IconKind::Mask}},\n')
        f.write("};\n\n")

        f.write("bool icon_registry_lookup(const char* icon_id, IconRef* out) {\n")
        f.write("  if (!out) return false;\n")
        f.write("  out->dsc = nullptr;\n")
        f.write("  out->kind = IconKind::Mask;\n")
        f.write("  if (!icon_id || !*icon_id) return false;\n\n")
        f.write("  for (size_t i = 0; i < (sizeof(kIcons) / sizeof(kIcons[0])); i++) {\n")
        f.write("    if (strcmp(icon_id, kIcons[i].id) == 0) {\n")
        f.write("      out->dsc = kIcons[i].dsc;\n")
        f.write("      out->kind = kIcons[i].kind;\n")
        f.write("      return true;\n")
        f.write("    }\n")
        f.write("  }\n")
        f.write("  return false;\n")
        f.write("}\n\n")

        f.write("size_t icon_registry_count() {\n")
        f.write("  return (sizeof(kIcons) / sizeof(kIcons[0]));\n")
        f.write("}\n\n")

        f.write("const char* icon_registry_id_at(size_t index) {\n")
        f.write("  const size_t n = (sizeof(kIcons) / sizeof(kIcons[0]));\n")
        f.write("  if (index >= n) return nullptr;\n")
        f.write("  return kIcons[index].id;\n")
        f.write("}\n\n")

        f.write("IconKind icon_registry_kind_at(size_t index) {\n")
        f.write("  const size_t n = (sizeof(kIcons) / sizeof(kIcons[0]));\n")
        f.write("  if (index >= n) return IconKind::Mask;\n")
        f.write("  return kIcons[index].kind;\n")
        f.write("}\n\n")

        f.write("#endif // HAS_DISPLAY && HAS_ICONS\n")


def main() -> int:
    ap = argparse.ArgumentParser(description="Generate icon registry source files")
    ap.add_argument("--mono-h", required=True, help="Generated mono icon header (icon_assets_mono.h)")
    ap.add_argument("--out-h", required=True, help="Output registry header path")
    ap.add_argument("--out-cpp", required=True, help="Output registry cpp path")
    ap.add_argument("--symbol-prefix", default="ic_", help="Icon symbol prefix (default: ic_)")

    args = ap.parse_args()

    mono = _read_symbols(args.mono_h, expected_prefix=args.symbol_prefix)
    color: List[IconSym] = []

    os.makedirs(os.path.dirname(args.out_h) or ".", exist_ok=True)
    os.makedirs(os.path.dirname(args.out_cpp) or ".", exist_ok=True)

    _write_header(args.out_h)
    _write_cpp(args.out_cpp, os.path.basename(args.out_h), mono)

    print(f"✓ Icon registry: mono={len(mono)}")
    print(f"✓ Wrote {args.out_h}")
    print(f"✓ Wrote {args.out_cpp}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
