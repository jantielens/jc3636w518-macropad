#!/usr/bin/env python3
"""Convert top-level PNG files to LVGL 8.x image descriptors.


Requirements:

Example:
    python3 tools/png2lvgl_assets.py assets/png src/app/png_assets.cpp src/app/png_assets.h --prefix img_
"""

from __future__ import annotations

import argparse
import os
import re
import sys
from dataclasses import dataclass
from enum import Enum
from typing import List, Tuple


try:
    from PIL import Image
except Exception as exc:  # pragma: no cover
    print(
        "ERROR: Python dependency 'Pillow' is required for PNG conversion.\n"
        "\n"
        "Install it with:\n"
        "  python3 -m pip install --user pillow\n"
        "\n"
        f"Details: {exc}",
        file=sys.stderr,
    )
    sys.exit(2)


_VALID_C_IDENT = re.compile(r"^[A-Za-z_][A-Za-z0-9_]*$")


class LvglColorFormat(str, Enum):
    TRUE_COLOR_ALPHA = "true_color_alpha"
    ALPHA_8BIT = "alpha_8bit"
    ALPHA_4BIT = "alpha_4bit"


@dataclass(frozen=True)
class LvglImage:
    symbol: str
    width: int
    height: int
    data: bytes
    lv_cf: str
    map_name: str
    source_file: str


def _load_png_rgba(png_path: str) -> "Image.Image":
    img = Image.open(png_path)
    return img.convert("RGBA")


def _enforce_or_resize_square(img: "Image.Image", png_path: str, size: int, resize: bool) -> "Image.Image":
    width, height = img.size
    if width == size and height == size:
        return img

    if not resize:
        raise SystemExit(
            "ERROR: PNG has unexpected size.\n"
            f"  File: {png_path}\n"
            f"  Got:  {width}x{height}\n"
            f"  Need: {size}x{size}\n"
            "\n"
            "Fix: resize the PNG to the expected size, or pass --resize to auto-resize."
        )

    # Stretch resize. (For icons, designers should ideally export at the right size.)
    return img.resize((size, size), resample=Image.Resampling.LANCZOS)


def _rgba_to_true_color_alpha_bytes(img: "Image.Image") -> bytes:
    # LVGL TRUE_COLOR_ALPHA: RGB565 (LE, 2 bytes) + alpha (1 byte) per pixel.
    pixels = list(img.getdata())
    out = bytearray()
    out_extend = out.extend

    for r, g, b, a in pixels:
        r5 = (r >> 3) & 0x1F
        g6 = (g >> 2) & 0x3F
        b5 = (b >> 3) & 0x1F
        rgb565 = (r5 << 11) | (g6 << 5) | b5
        out_extend((rgb565 & 0xFF, (rgb565 >> 8) & 0xFF, a))

    return bytes(out)


def _rgba_to_alpha8_bytes(img: "Image.Image") -> bytes:
    pixels = list(img.getdata())
    out = bytearray(len(pixels))
    for i, (_r, _g, _b, a) in enumerate(pixels):
        out[i] = a
    return bytes(out)


def _rgba_to_alpha4_bytes(img: "Image.Image") -> bytes:
    pixels = list(img.getdata())
    out = bytearray((len(pixels) + 1) // 2)
    oi = 0
    hi = True
    cur = 0
    for (_r, _g, _b, a) in pixels:
        a4 = (a >> 4) & 0x0F
        if hi:
            cur = (a4 << 4)
            hi = False
        else:
            cur |= a4
            out[oi] = cur
            oi += 1
            hi = True

    if not hi:
        out[oi] = cur
    return bytes(out)


def _list_top_level_pngs(input_dir: str) -> List[str]:
    try:
        entries = os.listdir(input_dir)
    except FileNotFoundError:
        raise SystemExit(f"ERROR: Input directory not found: {input_dir}")

    pngs = []
    for name in sorted(entries):
        full = os.path.join(input_dir, name)
        if not os.path.isfile(full):
            continue
        if name.lower().endswith(".png"):
            pngs.append(full)
    return pngs


def _validate_symbol_name(symbol: str, source_file: str) -> None:
    if not _VALID_C_IDENT.match(symbol):
        raise SystemExit(
            "ERROR: Invalid PNG filename for C symbol generation.\n"
            f"  File: {source_file}\n"
            f"  Derived symbol: {symbol}\n"
            "\n"
            "Expected filename base to match C identifier rules:\n"
            "  - starts with [A-Za-z_]\n"
            "  - then only [A-Za-z0-9_]\n"
            "\n"
            "Fix: rename the PNG file to a safe name (e.g. 'logo_main.png')."
        )


def _write_header(path_h: str, images: List[LvglImage]) -> None:
    guard = "PNG_ASSETS_H"
    with open(path_h, "w", encoding="utf-8") as f:
        f.write("/*\n")
        f.write(" * Auto-generated PNG asset declarations\n")
        f.write(" * Generated by tools/png2lvgl_assets.py\n")
        f.write(" * DO NOT EDIT MANUALLY\n")
        f.write(" */\n\n")
        f.write(f"#ifndef {guard}\n")
        f.write(f"#define {guard}\n\n")
        f.write('#include "board_config.h"\n\n')
        f.write("#if HAS_DISPLAY\n")
        f.write("#include <lvgl.h>\n\n")
        f.write("#ifdef __cplusplus\n")
        f.write("extern \"C\" {\n")
        f.write("#endif\n\n")
        f.write("// PNG asset declarations\n")
        for img in images:
            f.write(f"extern const lv_img_dsc_t {img.symbol};\n")
        f.write("\n#ifdef __cplusplus\n")
        f.write("}\n")
        f.write("#endif\n")
        f.write("\n#endif // HAS_DISPLAY\n\n")
        f.write(f"#endif // {guard}\n")


def _write_c(path_c: str, header_basename: str, images: List[LvglImage]) -> None:
    with open(path_c, "w", encoding="utf-8") as f:
        f.write("/*\n")
        f.write(" * Auto-generated PNG asset definitions\n")
        f.write(" * Generated by tools/png2lvgl_assets.py\n")
        f.write(" * DO NOT EDIT MANUALLY\n")
        f.write(" */\n\n")
        f.write(f'#include "{header_basename}"\n\n')
        f.write("#if HAS_DISPLAY\n\n")

        # Ensure attribute macros exist (LVGL compatibility)
        f.write("#ifndef LV_ATTRIBUTE_MEM_ALIGN\n")
        f.write("#define LV_ATTRIBUTE_MEM_ALIGN\n")
        f.write("#endif\n\n")

        f.write("#ifndef LV_ATTRIBUTE_IMG_\n")
        f.write("#define LV_ATTRIBUTE_IMG_\n")
        f.write("#endif\n\n")

        for img in images:
            f.write(f"// {img.width}x{img.height} RGBA PNG: {os.path.basename(img.source_file)}\n")
            f.write(
                f"const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_IMG_ uint8_t {img.map_name}[] = {{\n"
            )

            data = img.data
            # Write 12 bytes per line (4 pixels * 3 bytes)
            for i in range(0, len(data), 12):
                chunk = data[i : i + 12]
                hexes = ", ".join(f"0x{b:02x}" for b in chunk)
                if i + 12 < len(data):
                    f.write(f"  {hexes},\n")
                else:
                    f.write(f"  {hexes}\n")

            f.write("};\n\n")

            f.write(f"const lv_img_dsc_t {img.symbol} = {{\n")
            f.write("  {\n")
            f.write(f"    {img.lv_cf},\n")
            f.write("    0,\n")
            f.write("    0,\n")
            f.write(f"    {img.width},\n")
            f.write(f"    {img.height},\n")
            f.write("  },\n")
            f.write(f"  {len(data)},\n")
            f.write(f"  {img.map_name},\n")
            f.write("};\n\n")

        f.write("#endif // HAS_DISPLAY\n")


def main() -> int:
    ap = argparse.ArgumentParser(description="Convert PNGs to LVGL C arrays")
    ap.add_argument("input_dir", help="Directory containing PNG files (top-level only)")
    ap.add_argument("output_c", help="Output .c file path")
    ap.add_argument("output_h", help="Output .h file path")
    ap.add_argument("--prefix", default="img_", help="Symbol name prefix (default: img_)")
    ap.add_argument(
        "--format",
        default=LvglColorFormat.TRUE_COLOR_ALPHA.value,
        choices=[e.value for e in LvglColorFormat],
        help="Output LVGL color format: true_color_alpha (default), alpha_8bit, alpha_4bit",
    )
    ap.add_argument(
        "--size",
        type=int,
        default=0,
        help="If set, require square PNGs of this size (e.g. 64).",
    )
    ap.add_argument(
        "--resize",
        action="store_true",
        help="If --size is set and PNGs are not the right size, auto-resize to the requested size.",
    )

    args = ap.parse_args()

    input_dir = args.input_dir
    output_c = args.output_c
    output_h = args.output_h
    prefix = args.prefix
    fmt = LvglColorFormat(args.format)
    size = int(args.size or 0)
    resize = bool(args.resize)

    if not os.path.isdir(input_dir):
        raise SystemExit(f"ERROR: Input directory not found: {input_dir}")

    png_files = _list_top_level_pngs(input_dir)

    images: List[LvglImage] = []
    seen_symbols = set()

    for png_path in png_files:
        base = os.path.splitext(os.path.basename(png_path))[0]
        symbol = f"{prefix}{base}"
        _validate_symbol_name(base, png_path)
        _validate_symbol_name(symbol, png_path)

        if symbol in seen_symbols:
            raise SystemExit(
                "ERROR: Duplicate symbol name derived from PNG filenames.\n"
                f"  Symbol: {symbol}\n"
                f"  File: {png_path}\n"
                "\n"
                "Fix: ensure each PNG filename is unique."
            )
        seen_symbols.add(symbol)

        img = _load_png_rgba(png_path)
        if size > 0:
            img = _enforce_or_resize_square(img, png_path, size=size, resize=resize)

        width, height = img.size

        if fmt == LvglColorFormat.TRUE_COLOR_ALPHA:
            data = _rgba_to_true_color_alpha_bytes(img)
            lv_cf = "LV_IMG_CF_TRUE_COLOR_ALPHA"
        elif fmt == LvglColorFormat.ALPHA_8BIT:
            data = _rgba_to_alpha8_bytes(img)
            lv_cf = "LV_IMG_CF_ALPHA_8BIT"
        elif fmt == LvglColorFormat.ALPHA_4BIT:
            data = _rgba_to_alpha4_bytes(img)
            lv_cf = "LV_IMG_CF_ALPHA_4BIT"
        else:
            raise SystemExit(f"ERROR: Unsupported format: {fmt}")

        images.append(
            LvglImage(
                symbol=symbol,
                width=width,
                height=height,
                data=data,
                lv_cf=lv_cf,
                map_name=f"{symbol}_map",
                source_file=png_path,
            )
        )

    os.makedirs(os.path.dirname(output_h) or ".", exist_ok=True)
    os.makedirs(os.path.dirname(output_c) or ".", exist_ok=True)

    # Always generate files (even if no PNGs) so includes remain stable.
    _write_header(output_h, images)
    _write_c(output_c, os.path.basename(output_h), images)

    print(f"✓ PNG assets: {len(images)} file(s)")
    total_bytes = 0
    for img in images:
        size_bytes = len(img.data)
        total_bytes += size_bytes
        print(
            f"  - {os.path.basename(img.source_file)} -> {img.symbol} "
            f"({img.width}x{img.height}, {img.lv_cf}) : {size_bytes} bytes in firmware"
        )
    print(f"✓ PNG assets total: {total_bytes} bytes in firmware")
    print(f"✓ Wrote {output_h}")
    print(f"✓ Wrote {output_c}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
