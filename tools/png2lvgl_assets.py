#!/usr/bin/env python3
"""Convert top-level PNG files to LVGL 8.x image descriptors.


Requirements:

Example:
    python3 tools/png2lvgl_assets.py assets/png src/app/png_assets.cpp src/app/png_assets.h --prefix img_
"""

from __future__ import annotations

import argparse
import os
import re
import sys
from dataclasses import dataclass
from typing import List, Tuple


try:
    from PIL import Image
except Exception as exc:  # pragma: no cover
    print(
        "ERROR: Python dependency 'Pillow' is required for PNG conversion.\n"
        "\n"
        "Install it with:\n"
        "  python3 -m pip install --user pillow\n"
        "\n"
        f"Details: {exc}",
        file=sys.stderr,
    )
    sys.exit(2)


_VALID_C_IDENT = re.compile(r"^[A-Za-z_][A-Za-z0-9_]*$")


@dataclass(frozen=True)
class LvglImage:
    symbol: str
    width: int
    height: int
    data: bytes
    map_name: str
    source_file: str


def _read_png_to_true_color_alpha_bytes(png_path: str) -> Tuple[int, int, bytes]:
    img = Image.open(png_path)
    img = img.convert("RGBA")

    width, height = img.size
    pixels = list(img.getdata())

    # LVGL TRUE_COLOR_ALPHA: RGB565 (LE, 2 bytes) + alpha (1 byte) per pixel.
    out = bytearray()
    out_extend = out.extend

    for r, g, b, a in pixels:
        r5 = (r >> 3) & 0x1F
        g6 = (g >> 2) & 0x3F
        b5 = (b >> 3) & 0x1F
        rgb565 = (r5 << 11) | (g6 << 5) | b5

        out_extend((rgb565 & 0xFF, (rgb565 >> 8) & 0xFF, a))

    return width, height, bytes(out)


def _list_top_level_pngs(input_dir: str) -> List[str]:
    try:
        entries = os.listdir(input_dir)
    except FileNotFoundError:
        raise SystemExit(f"ERROR: Input directory not found: {input_dir}")

    pngs = []
    for name in sorted(entries):
        full = os.path.join(input_dir, name)
        if not os.path.isfile(full):
            continue
        if name.lower().endswith(".png"):
            pngs.append(full)
    return pngs


def _validate_symbol_name(symbol: str, source_file: str) -> None:
    if not _VALID_C_IDENT.match(symbol):
        raise SystemExit(
            "ERROR: Invalid PNG filename for C symbol generation.\n"
            f"  File: {source_file}\n"
            f"  Derived symbol: {symbol}\n"
            "\n"
            "Expected filename base to match C identifier rules:\n"
            "  - starts with [A-Za-z_]\n"
            "  - then only [A-Za-z0-9_]\n"
            "\n"
            "Fix: rename the PNG file to a safe name (e.g. 'logo_main.png')."
        )


def _write_header(path_h: str, images: List[LvglImage]) -> None:
    guard = "PNG_ASSETS_H"
    with open(path_h, "w", encoding="utf-8") as f:
        f.write("/*\n")
        f.write(" * Auto-generated PNG asset declarations\n")
        f.write(" * Generated by tools/png2lvgl_assets.py\n")
        f.write(" * DO NOT EDIT MANUALLY\n")
        f.write(" */\n\n")
        f.write(f"#ifndef {guard}\n")
        f.write(f"#define {guard}\n\n")
        f.write('#include "board_config.h"\n\n')
        f.write("#if HAS_DISPLAY\n")
        f.write("#include <lvgl.h>\n\n")
        f.write("#ifdef __cplusplus\n")
        f.write("extern \"C\" {\n")
        f.write("#endif\n\n")
        f.write("// PNG asset declarations\n")
        for img in images:
            f.write(f"extern const lv_img_dsc_t {img.symbol};\n")
        f.write("\n#ifdef __cplusplus\n")
        f.write("}\n")
        f.write("#endif\n")
        f.write("\n#endif // HAS_DISPLAY\n\n")
        f.write(f"#endif // {guard}\n")


def _write_c(path_c: str, header_basename: str, images: List[LvglImage]) -> None:
    with open(path_c, "w", encoding="utf-8") as f:
        f.write("/*\n")
        f.write(" * Auto-generated PNG asset definitions\n")
        f.write(" * Generated by tools/png2lvgl_assets.py\n")
        f.write(" * DO NOT EDIT MANUALLY\n")
        f.write(" */\n\n")
        f.write(f'#include "{header_basename}"\n\n')
        f.write("#if HAS_DISPLAY\n\n")

        # Ensure attribute macros exist (LVGL compatibility)
        f.write("#ifndef LV_ATTRIBUTE_MEM_ALIGN\n")
        f.write("#define LV_ATTRIBUTE_MEM_ALIGN\n")
        f.write("#endif\n\n")

        f.write("#ifndef LV_ATTRIBUTE_IMG_\n")
        f.write("#define LV_ATTRIBUTE_IMG_\n")
        f.write("#endif\n\n")

        for img in images:
            f.write(f"// {img.width}x{img.height} RGBA PNG: {os.path.basename(img.source_file)}\n")
            f.write(
                f"const LV_ATTRIBUTE_MEM_ALIGN LV_ATTRIBUTE_IMG_ uint8_t {img.map_name}[] = {{\n"
            )

            data = img.data
            # Write 12 bytes per line (4 pixels * 3 bytes)
            for i in range(0, len(data), 12):
                chunk = data[i : i + 12]
                hexes = ", ".join(f"0x{b:02x}" for b in chunk)
                if i + 12 < len(data):
                    f.write(f"  {hexes},\n")
                else:
                    f.write(f"  {hexes}\n")

            f.write("};\n\n")

            f.write(f"const lv_img_dsc_t {img.symbol} = {{\n")
            f.write("  {\n")
            f.write("    LV_IMG_CF_TRUE_COLOR_ALPHA,\n")
            f.write("    0,\n")
            f.write("    0,\n")
            f.write(f"    {img.width},\n")
            f.write(f"    {img.height},\n")
            f.write("  },\n")
            f.write(f"  {len(data)},\n")
            f.write(f"  {img.map_name},\n")
            f.write("};\n\n")

        f.write("#endif // HAS_DISPLAY\n")


def main() -> int:
    ap = argparse.ArgumentParser(description="Convert PNGs to LVGL C arrays")
    ap.add_argument("input_dir", help="Directory containing PNG files (top-level only)")
    ap.add_argument("output_c", help="Output .c file path")
    ap.add_argument("output_h", help="Output .h file path")
    ap.add_argument("--prefix", default="img_", help="Symbol name prefix (default: img_)")

    args = ap.parse_args()

    input_dir = args.input_dir
    output_c = args.output_c
    output_h = args.output_h
    prefix = args.prefix

    if not os.path.isdir(input_dir):
        raise SystemExit(f"ERROR: Input directory not found: {input_dir}")

    png_files = _list_top_level_pngs(input_dir)

    images: List[LvglImage] = []
    seen_symbols = set()

    for png_path in png_files:
        base = os.path.splitext(os.path.basename(png_path))[0]
        symbol = f"{prefix}{base}"
        _validate_symbol_name(base, png_path)
        _validate_symbol_name(symbol, png_path)

        if symbol in seen_symbols:
            raise SystemExit(
                "ERROR: Duplicate symbol name derived from PNG filenames.\n"
                f"  Symbol: {symbol}\n"
                f"  File: {png_path}\n"
                "\n"
                "Fix: ensure each PNG filename is unique."
            )
        seen_symbols.add(symbol)

        width, height, data = _read_png_to_true_color_alpha_bytes(png_path)

        images.append(
            LvglImage(
                symbol=symbol,
                width=width,
                height=height,
                data=data,
                map_name=f"{symbol}_map",
                source_file=png_path,
            )
        )

    os.makedirs(os.path.dirname(output_h) or ".", exist_ok=True)
    os.makedirs(os.path.dirname(output_c) or ".", exist_ok=True)

    # Always generate files (even if no PNGs) so includes remain stable.
    _write_header(output_h, images)
    _write_c(output_c, os.path.basename(output_h), images)

    print(f"✓ PNG assets: {len(images)} file(s)")
    total_bytes = 0
    for img in images:
        size_bytes = len(img.data)
        total_bytes += size_bytes
        print(
            f"  - {os.path.basename(img.source_file)} -> {img.symbol} "
            f"({img.width}x{img.height}) : {size_bytes} bytes in firmware"
        )
    print(f"✓ PNG assets total: {total_bytes} bytes in firmware")
    print(f"✓ Wrote {output_h}")
    print(f"✓ Wrote {output_c}")

    return 0


if __name__ == "__main__":
    raise SystemExit(main())
